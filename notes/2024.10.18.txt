I looked through the changes one more time
and tested it, it works.
I tested it by adding 2 words in each word set,
closing the application,
confirming that .data files are updated,
opening the application again to confirm that new words will be loaded correctly.
So it's ready. Adding a new word is fully ready.
Let's commit.


Now let's continue with implementing adding a new word set.
Hopefully it will be similar, but simpler since a word set doesn't have any other object containing it.
Start by adding another "New" button, this time under word sets list widget.
Done, easy, looks good.

Now let's create a dialog that will open up when this "New" button is clicked
    CreateWordSetDialog.h
    CreateWordSetDialog.cpp
    class CreateWordSetDialog
Copy contents of .h and .cpp file from
    CreateWordDialog.h
    CreateWordDialog.cpp
We need basically the same thing but just with 1 line edit for the set's name, for now.
Done, easy, looks good.
Does nothing yet, but the correct signal in WordLearnerMainWindow is called with the entered name.

What's left now is to implement the actual creation of the word set
when CreateWordSetDialog is finished.
First we will need a new public function in Database
    int createWordSet(const std::string& name)
that will create a new word set with given name.
Then implement
    onCreateWordSet()
to actually create the word set by calling Database's new function createWordSet()
and update the word sets list widget.
For that we will need to refactor filling of word sets list widget from createWordSetsUi() to a new function
    updateWordSetsListWidget()
(same as for word)
Okay, I think it's ready.
Let's test.
It works!
I tried creating a few new word sets,
adding words to them,
exiting application, confirming that they export to .data files correctly,
starting application again, confirming that new word sets show up and contain the added words.

Oh actually I noticed one thing.
After a new word set is created I want it to become the selected word set automatically.
For that we will need a new parameter to this function
    updateWordSetsListWidget()
that will specify an ID of the word set that we want to be selected at the beginning.
    void updateWordSetsListWidget(const std::vector<WordSet>& wordSets, int selectedWordSetId = -1);
Okay and now we can just pass the ID of the newly created word set to updateWordSetsListWidget() in
    onCreateWordSet()
And now we don't even need to manually update words list
because when we change the selected word set our slot is called
    onWordSetChanged()
and words list is updated automatically.
Let's test.
It works.

Okay, so creating word sets is done.
Let's commit.



Now it's time to start with editing words and editing word sets.
This time I will start with word sets, because it's simpler.
So let's implement editing word sets.
The only thing that can be edited in a word set is its name.
So I should make the list items be editable,
and every time an item is edited some slot should be called.
The slot will be this
    void onWordSetEdited(QListWidgetItem* item);
It kinda works now,
the only problem is that the slot is also called when items are created at launch time
and when a new word set is created by user.
A solution would be to temporarily disconnect the itemChanged() signal
while adding items programatically in
    updateWordSetsListWidget()
and then at the end of the function connect it again.
This function is the only place where we add items to that list, so it should be enough.
Yep, it works.
Okay, it's ready.
Items are editable now, and we have a slot that's called when an item is edited in UI.
Let's commit.
